grammar;

// ===== LEXER =====
use super::lexer::Token;
use super::lalrpop_lexer::LexicalError;

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "let" => Token::KeywordLet,
    "fn" => Token::KeywordFn,
    "if" => Token::KeywordIf,
    "then" => Token::KeywordThen,
    "else" => Token::KeywordElse,
    "identifier" => Token::Identifier(<String>),
    "int" => Token::Integer(<i64>),
    "bool" => Token::Boolean(<bool>),
    "::" => Token::DoubleColon,
    "," => Token::Comma,
    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "[" => Token::LBracket,
    "]" => Token::RBracket,
    "=" => Token::Assign,
    ";" => Token::Semicolon,
    "+" => Token::OperatorAdd,
    "-" => Token::OperatorSub,
    "*" => Token::OperatorMul,
    "/" => Token::OperatorDiv,
    "||" => Token::OperatorOr,
    "&&" => Token::OperatorAnd,
    "==" => Token::OperatorEqual,
    "!=" => Token::OperatorNotEqual,
  }
}

// ===== PARSER =====
use super::ast::{Expr, Atom, Opcode};

// Define the main expressions with proper handling of optional elements and clear precedence
pub Expr: Expr = {
    <cond:IfExpr> => cond,
    <block:Block> => Expr::Block(block),
    <or:OrExpr> => or
};

// If expression with and without else part
IfExpr: Expr = {
    "if" <cond:Expr> "then" <then_part:Expr> "else" <else_part:Expr> => {
        Expr::IfElse(Box::new(cond), Box::new(then_part), Some(Box::new(else_part)))
    }
};

// Define a clearer list of expressions handling
Exprs: Vec<Expr> = {
    <head:Expr> <tail:(";" <Expr>)*> => {
        let mut exprs = vec![head];
        for expr in tail {
            exprs.push(expr);
        }
        exprs
    }
};

// Block of expressions (might be empty)
Block: Vec<Expr> = {
    "{" <exprs:Exprs?> "}" => exprs.unwrap_or(vec![])
};

// ==== Precedence climbing ====
// Binary
BinaryTier<Op, NextTier>: Expr = {
    <left:BinaryTier<Op, NextTier>> <op:Op> <right:NextTier> => Expr::BinaryOp(Box::new(left), op, Box::new(right)),
    NextTier
};
OrOp: Opcode = {
    "||" => Opcode::Or
};
OrExpr: Expr = BinaryTier<OrOp, AndExpr>;
AndOp: Opcode = {
    "&&" => Opcode::And
};
AndExpr: Expr = BinaryTier<AndOp, EqualityExpr>;
EqualityOp: Opcode = {
    "==" => Opcode::Equal,
    "!=" => Opcode::NotEqual
};
EqualityExpr: Expr = BinaryTier<EqualityOp, AddSubExpr>;
AddSubOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub
};
AddSubExpr: Expr = BinaryTier<AddSubOp, MulDivExpr>;
MulDivOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div
};
MulDivExpr: Expr = BinaryTier<MulDivOp, UnaryExpr>;

// Unary
UnaryExpr: Expr = {
    "-" <expr:UnaryExpr> => Expr::UnaryOp(Opcode::Neg, Box::new(expr)),
    <function:FunctionCallExpr> => function
};
FunctionCallExpr: Expr = {
    <callee:FunctionCallExpr> "(" <arg:Expr> ")" => Expr::FunctionCall(Box::new(callee), Box::new(arg)),
    <constant:ConstantExpr> => constant,
};
ConstantExpr: Expr = {
    <atom:Atom> => Expr::Constant(atom),
    "(" <expr:Expr> ")" => expr
};

// Define identifiers with a clear regex pattern
Ident: String = <name:"identifier"> => name.to_string();

// Define atoms ensuring that the patterns are distinct and non-overlapping
Atom: Atom = {
    <num:"int"> => Atom::Num(num),
    <boolean:"bool"> => Atom::Boolean(boolean),
    <identifier:Ident> => Atom::Identifier(identifier)
};

// Define a clearer comma-separated list handling
Comma<T>: Vec<T> = {
    <head:T> <tail:("," <T>)*> => {
        let mut elems = vec![head];
        for elem in tail {
            elems.push(elem);
        }
        elems
    }
};